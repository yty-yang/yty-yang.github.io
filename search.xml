<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Hello World</title>
    <url>/2023/05/26/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>
]]></content>
  </entry>
  <entry>
    <title>花了一些时间大概折腾完Blog页面后的一点点体会</title>
    <url>/2023/05/27/%E8%8A%B1%E4%BA%86%E4%B8%80%E4%BA%9B%E6%97%B6%E9%97%B4%E5%A4%A7%E6%A6%82%E6%8A%98%E8%85%BE%E5%AE%8Cblog%E9%A1%B5%E9%9D%A2%E5%90%8E%E7%9A%84%E4%B8%80%E7%82%B9%E7%82%B9%E4%BD%93%E4%BC%9A/</url>
    <content><![CDATA[<p>现在这个网站肯定只有我一个人会看啦所以文章什么的就随便写写，<del>（如果，我是说如果，有浏览量了的话，这种黑历史肯定删的一干二净👊👊）</del></p>
<p>做这个网站是因为闲的没事 <del>（其实有事但不想做，所以就会转而做各种乱七八糟的事情）</del>，以及国际考要结束后准备下定决心写点代码了（虽然看起来这个博客的技术浓度应该很低）</p>
<p>本来一直对调包作业非常鄙夷，毕竟 <strong>“调包谁不会嘛！又不是自己写的。。。”</strong> 嗯，上手之后：<strong>居然真的有人不会，是谁👀，是我😊</strong>（因此没有了不学machine learning的理由😂）</p>
<p>前端 <del>（处在鄙视链底端的存在）</del>，虽然确实容易上手，也不需要动脑子，但是确实急需熟练工和美术生😭。。。花几个小时贴几张图，还贴出一道缝出来做出来的东西也不是不能用，就是用的让人有一种想要去世的冲动。</p>
<p>现在再想想整个过程，在csdn的垃圾堆中刨取富有一些营养的垃圾 <del>嗯不过确实我觉得有几个高质量的帖子的还是不过也有可能我太菜了看什么都觉得好nb</del>，其实也没有那么难弄（哦！虽然确实有个问题没解决。。。解决的方法是删掉从来一遍不知道为什么又好了），就是自己亲生经历的时候容易感到暴躁😡，以及在百度Google上逛来逛去找不到答案的暴！！！躁！！！</p>
<p>打到这里发现markdown语法雀食好用为什么我之前都不用呢。。。不过我很喜欢他界面的一个软件‘Effie’虽然说起来也是markdown但他的语法有点奇怪，在这里总结下正统markdown语法练习一下吧顺便（嗯总结完我肯定起床吃早饭写卷子去 i hope）(btw it’s rly annoying to keep changing my ime while using markdown)</p>
<h1 id="一级标题"><a href="#一级标题" class="headerlink" title="# 一级标题"></a># 一级标题</h1><h2 id="二级标题"><a href="#二级标题" class="headerlink" title="## 二级标题"></a>## 二级标题</h2><h4 id="以此类推…"><a href="#以此类推…" class="headerlink" title="以此类推…"></a>以此类推…</h4><h6 id="六级标题（最小了）"><a href="#六级标题（最小了）" class="headerlink" title="###### 六级标题（最小了）"></a>###### 六级标题（最小了）</h6><p><em><strong>***加粗斜体***</strong></em><br><strong>**加粗**</strong><br><em>*斜体*</em></p>
<p>~~~~删除~~~~</p>
<p>中国有句古话： </p>
<blockquote>
<p>西西误解为俊杰（引用：是这个符号 ➡️ &gt; ）</p>
</blockquote>
<hr>
<p>—我是分割线—（我是说分割线就是—打出来的郝）</p>
<h2 id="还可以这样用！"><a href="#还可以这样用！" class="headerlink" title="还可以这样用！"></a>还可以这样用！</h2><p>（指分割线上方的字变成二级标题）</p>
<hr>
<p>嗯还可以插图片但是传博客好像有点麻烦下次再看吧</p>
<p><a href="http://baidu.com/" title="baidu">百度</a>嗯超链接可以，格式是： [name](address “title”)</p>
<p>打到这里我开始理解为什么有中国人写english blog了</p>
<p>今天就这么多啦，下次再见👋（一定要听我插在左边的房猫的歌啊🤩）</p>
]]></content>
      <categories>
        <category>发疯日常</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>markdown</tag>
      </tags>
  </entry>
  <entry>
    <title>Self Balancing Tree Summary</title>
    <url>/2023/08/02/Self-Balancing-Tree-summary/</url>
    <content><![CDATA[<h1 id="自平衡树的一些总结"><a href="#自平衡树的一些总结" class="headerlink" title="自平衡树的一些总结"></a>自平衡树的一些总结</h1><p>最近在学cs61b， 然后夏校要写个结课essay，正好就总结一下最近学的这几个data structure。</p>
<p>因为是essay，练习了一下LaTeX。懒得去看怎么让hexo支持LaTeX语法了，就直接把pdf版贴过来。<br><a href="/pdf/self_balancing_tree.pdf">pdf</a></p>
]]></content>
      <categories>
        <category>学习相关</category>
      </categories>
      <tags>
        <tag>summary</tag>
        <tag>cs61b</tag>
      </tags>
  </entry>
  <entry>
    <title>CS61b Project2: Main Structure of My Gitlet</title>
    <url>/2023/08/03/CS61b-project2-main-structure-of-my-gitlet/</url>
    <content><![CDATA[<p>CS61b的精髓：project2。在埋头写完四五个功能之后写到checkout，脑子已经乱的不行了，都不知道自己创建了什么文件夹，都有哪些类每个类放哪里…确实，按照note需要写一个gitlet-design的文档说明gitlet的结构。本来以为这主要是规范化，让别人能读懂写出来的代码，没想到项目时间超过一天，确实是睡一觉之后昨天写的就是别人写的，根本不知道是什么意思。</p>
<p>现在，鉴于我已经不大知道我写了什么了，必须得及时止损忍痛重写。“先把结构规划好，再填补细节”的习惯现在看起来是非常的重要。代码简单，只有一条线性的逻辑的时候脑袋里想一想，细节和框架一起出来了就顺着写下去，等到代码复杂的时候，眼光就会被局限在细节的地方，写到后面才发现有很多其他的操作也会影响之前的操作，然后不断改来改去。所以说，在经历痛打之后大家就会意识到abstraction确实是非常有用的方法。</p>
<p>anyway，下一部分是我的gitlet的结构（我觉得应该先想文件存放在哪里，文件夹怎么套，文件里存什么，然后再想怎么写code操作这些文件。文件夹分好了，代码也大差不差，基本上一个class对应一个文件夹吧）</p>
<p><img src="/../image/gitlet_structure.png" alt="image"></p>
<p><strong>init</strong></p>
<ol>
<li>create <em>GITLET_DIR</em></li>
<li>create <em>Blobs</em></li>
<li>create <em>Commits</em><br>new a commit(auto commit, no parent, empty fileversion)<br>new a tree, add the commit to it, save</li>
<li>create <em>Branches</em><br>new a branch(named ‘master’), set auto commit as beginCommit and endCommit, save</li>
<li>create <em>Stages</em><br>new a stage, set branchName as ‘master’</li>
</ol>
<p><strong>add</strong></p>
<ol>
<li>create a blob, put &lt;file, blob&gt; into ‘addition’ in stage</li>
</ol>
<p><strong>commit</strong></p>
<ol>
<li>create a commit, set ‘fileversion’ as its parent commit’s ‘fileversion’</li>
<li>if a file is in ‘Addition’, overwirte the file in ‘fileversion’ by the version of that in ‘Addition’, clear ‘Addition’</li>
<li>if a file is in ‘Removal’, remove the file from stage, clear ‘Removal’</li>
<li>renew the endCommmit of the branch</li>
</ol>
<p><strong>rm</strong></p>
<ol>
<li>check if the file is in ‘Addition’; delete it and its corresponding blob if it’s in</li>
<li>check if the file is tracked in headcommit(if the ‘fileversion’ of head commit contains the file), put it in ‘Removal’ area of stage, delete it from workingdir</li>
</ol>
<p><strong>log</strong></p>
<ol>
<li>print head commit</li>
<li>print it’s parent commit</li>
</ol>
<p><strong>global-log</strong></p>
<ol>
<li>iterate the ‘Commits’ directory, print each of the commits.</li>
</ol>
<p><strong>find</strong></p>
<ol>
<li>iterate the ‘Commits’ directory, print the commits with the message looking for</li>
</ol>
<p><strong>status</strong></p>
<ol>
<li>print branch</li>
<li>print files in ‘Addition’</li>
<li>print files in ‘Removal’</li>
<li>check if all files that are tracked by headcommit and not in ‘Removal’ exist in workingdir, if not, save the file name</li>
<li>print files which are missing</li>
<li>create a blob of all files that exist in workingdir</li>
<li>compare them with the tracked version in headcommit, use a flag to store if it’s same or not.</li>
<li>compare them with the version in ‘Addition’(if they are in it), use a flag to store if it’s same or not.</li>
<li>print files’ name which are different</li>
<li>save files which are not tracked by headcommit, and not in ‘Addition’</li>
<li>print the files’ name</li>
</ol>
<p>（就是写到这个功能然后就发现乱七八糟）</p>
<p><strong>checkout</strong></p>
<ol>
<li>find the blob needed</li>
<li>overwrite the file in workingdir</li>
<li>put the new &lt;file, blob&gt; in ‘Addition’</li>
</ol>
]]></content>
      <categories>
        <category>学习相关</category>
      </categories>
      <tags>
        <tag>cs61b</tag>
      </tags>
  </entry>
  <entry>
    <title>Operating System</title>
    <url>/2024/02/06/Operating-system/</url>
    <content><![CDATA[<p>今天剑桥项目的助教突然有事没去，本牛津项目的助教被拉去救急。上次已经上过一遍剑桥的项目，感觉他的内容填的非常满过的很快。果不其然，今天讲操作系统，即使是第二次听课也还是晕晕乎乎，感觉上次听的内容全部都已经忘记了。又想到operation system的重要性，以及本科课程不可能讲的比这个还简单，决定整理吸收一下，把剑桥项目提到的东西吃透。（以及来参观一下本人没怎么动过的博客</p>
<h1 id="why-do-we-need-an-operating-system"><a href="#why-do-we-need-an-operating-system" class="headerlink" title="why do we need an operating system"></a>why do we need an operating system</h1><ul>
<li>We want to be able to run many programs at the same time</li>
<li>we need to prevent on program overwriting the data of other programs</li>
<li>we need to share resources(printer, hard disk, network…),</li>
<li>we need to share data with permissions</li>
</ul>
<h1 id="virtual-memory"><a href="#virtual-memory" class="headerlink" title="virtual memory"></a>virtual memory</h1><p><strong>principle: processes are independent</strong></p>
<p>Virtual memory lets every process(program instance) thinks that it is the <strong>only</strong> program on the computer, each process runs in a virtual address space, thus, they follow the principle.</p>
<h1 id="page"><a href="#page" class="headerlink" title="page"></a>page</h1><p>devide memory adresses into pages. For a 32-bit address(2^32 bytes), we devide it into blocks(usually 2^12 bytes), each block is called one page. Therefore, we have 2^20 pages in this scenario.</p>
<p><img src="/../image/page_adress.png" alt="image"></p>
<p>for each program, it thinks that it has the whole 2^32 bytes of memory, the operating system uses <strong>translation table</strong> to arange the pages’ physical address so that they won’t be at the same place.</p>
<p><img src="/../image/page_translation_table.png" alt="image"></p>
<p>But when whould the translation process accour? To keep the system secure, we need a new hardware support so the hardware automatically translates addresses and there is no way to turn off the translation system.</p>
<p><strong>Operating system</strong> creates the translation tables when a process is started, gives the translation table to <strong>a special unit inside the CPU</strong> called the <strong>translation lookaside buffer (TLB)</strong>.<br>(<strong>security:</strong> The kernel keeps the translation tables in physical memory but in places that are not the target of any process’s virtual to physical mapping. This is sufficient to prevent any process from changing any translation table.)</p>
<p>Whenever the process runs a LD or ST instruction, the CPU uses the TLB to translate the address before accessing memory.</p>
<h1 id="demand-paging"><a href="#demand-paging" class="headerlink" title="demand paging"></a>demand paging</h1><p>When there is no enough memory location, we can copy somepages that are not being used onto hard disk, then overwrite them in momory. This allows us to have more programs open at the same time without losing all the rest of their memory.</p>
<p><strong>resident bit(R bit)</strong>: a bit per entry in the translation table to indicate that whether the page is resident in the memory or not.</p>
<p>When a page is not resident, the bits allocated to the physical frame number are repurposed to tell us wehre on disk we saved the page.</p>
<p>If the running process tries to use an address that translates to a non resident page, goes to <strong>page fault interrupt</strong></p>
<h1 id="interrupts"><a href="#interrupts" class="headerlink" title="interrupts"></a>interrupts</h1><p>Interrupts allow the CPU to tell the operating system that sth. has happend and that it needs the operating system to decide how to sort it out.</p>
<p>Interrupts will solve several problems, so an interrupt comes with an integer which idicates what type of problem occurred.</p>
<p><strong>jump table(vector table): in physical memory beginning at address zero, the operating system puts a table of interrupt service routines: references to blocks of machine code that handle each type of problem</strong></p>
<h1 id="handling-interrupts"><a href="#handling-interrupts" class="headerlink" title="handling interrupts"></a>handling interrupts</h1><ol>
<li>interrupt occours</li>
<li>CPU <strong>saves program counter(PC)</strong> in a special CPU register </li>
<li>CPU looks up the interrupt number in jump table</li>
<li>set PC to <strong>the value found in the jump table</strong></li>
<li>CPU hardware <strong>turns off virtual address translation mechanism</strong>(so that it can have full access to the physical memory), execute the instructions</li>
<li>each interrupt service routine ends with a special instruction – <strong>RET</strong>, which <strong>turns on the translation mechanism again, restores the PC to the value saved in the special register</strong></li>
<li>run the program before interrupt as if nothing had happened</li>
</ol>
<h1 id="page-fault-interrupt"><a href="#page-fault-interrupt" class="headerlink" title="page fault interrupt"></a>page fault interrupt</h1><p>When the TLB attempts to translate a virtual address but finds that the corresponding translation table entry is non-resident, the TLB raise an interrupt with the integer corresponding to the code number for a page fault.</p>
<p>The corresponding interrupt service routine selects a <strong>victim page</strong> to move out of memory onto disk, then sends a command to the hard disk to cope the victim page from the memory to the disk, then copys the required page into memory, overwriting the victim page, then execute RET.</p>
<h1 id="optimisations"><a href="#optimisations" class="headerlink" title="optimisations"></a>optimisations</h1><ul>
<li>hard disk is much slower than CPU, the operating system will usually decide to run a different program while it waits for hard disk, then return to this one when the hard disk has finished copying data.</li>
<li>If the victim page has not been written to since it was pulled in from the disk, there is no need to write it out again – it’s the same as the copy on disk! By adding another dirty bit (D) to the translation table entries, we can keep track of whether a page needs to be copied out before it can be overwritten.</li>
</ul>
<h1 id="multilevel-paging"><a href="#multilevel-paging" class="headerlink" title="multilevel paging"></a>multilevel paging</h1><p>the translation tables are too large that consume lots of physical memory, we need to be able to <strong>push the translation tables for dormant processes out to the hard disk</strong>.</p>
<p>solution: make sure page tables are 1 page in size, using <strong>demand paging</strong>.</p>
<p>structure: a tree of tables. Each process will have a single, top-level (“root”) table, known as a page directory. The entries in the page directory are the physical frame numbers where small pieces of the page table can be found.</p>
]]></content>
      <categories>
        <category>学习相关</category>
      </categories>
      <tags>
        <tag>summary</tag>
        <tag>summerschool</tag>
      </tags>
  </entry>
</search>
